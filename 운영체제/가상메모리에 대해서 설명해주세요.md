## 운영체제 메모리의 꽃 가상메모리


## 가상메모리(virtual memory)
가상메모리는 실제 물리 메모리 개념과 개발자 입장의 논리 메모리 개념을 분리한 것입니다.
이렇게 함으로써 개발자가 메모리 크기 관련 문제를 염려할 필요 없이 쉽게 프로그램을 작성할 수 있게 해줍니다.
운영체제는 가상메모리 기법을 통해 
프로그램의 논리적 주소 영역에서 필요한 부분만 물리적 메모리에 적재하고,
직접적으로 필요하지 않는 논리 메모리 공간은 디스크(Swap 영역)에 저장하게 됩니다.
![image](https://github.com/acrnm148/CS_STUDY/assets/67724306/935e4916-d712-4fb5-973f-973914dda852)



## 가상메모리에 대해서 설명해주세요.
- 가상메모리(virtual memory)란 **프로세스 전체가 메모리에 올라오지 않더라도 실행이 가능**하도록 하는 기법입니다.
- 가상메모리 기법은 논리적 주소 영역에서 당장 사용될 메모리만 물리적 메모리에 적재하고, 당장 필요하지 않은 메모리는 디스크에 저장하는 방식입니다.


## 페이지 (Page)
- 논리적 주소 공간에서의 고정적인 단위
- DRAM에서 Row 하나하나에서 접근하는 컬럼의 개수
## 프레임 (Frame)
- 논리적 주소 공간을 고정된 크기로 나눈 단위가 **페이지(Page)** 라면,
- 물리적 주소 공간을 Page와 동일한 크기로 나눈 것을 **프레임(Frame)** 이라고 한다.
  

## 요구페이징 (demand paging)
- 당장 사용될 메모리를 **page 단위로 나누어** 메모리에 **적재**하는 방법입니다.
- 요구페이징 기법에서는 특정 page에 대해 CPU의 요청이 들어온 후에야 해당 page는 물리메모리에 적재가 됩니다.
  (아무page나 올리는게 아니라, CPU의 요청이 들어온 page만 올린다.)
  
- 장점) 1. 당장 실행에 필요한 page만 메모리에 적재되기 때문에 메모리 사용량이 감소합니다.
        2. 프로세스 전체를 메모리에 적재하는 입출력 오버헤드를 줄일 수 있습니다.
- 요구페이징은 각 page마다 유효/무효(valid/invalid) 비트를 사용하여 메모리에 적재되어 있는지 확인할 수 있습니다.
    => bit가 유효하면 메모리에 적재되어있는 것이고, 무효하면 메모리에 없음을 의미합니다.

- CPU가 A라는 page를 요청할 경우, 메모리에 적재되어있으므로 그냥 들어감. (이전에 CPU가 A를 요청한 적이 있는 것임.)
- CPU가 B라는 page를 요청할 경우, 메모리에 없어 접근할 수가 없으므로 **Page Fault**가 발생함.


## Page Fault
"CPU가 page를 요청했을 때 해당 page가 메모리에 없는 현상"
- CPU가 무효비트로 표시된 page에 접근하는 상황을 페이지 폴트(page fault)라고 합니다.
- CPU가 무효 page에 접근하면 주소 변환을 담당하는 하드웨어인 MMU가 page fault trap을 발생시키게 됩니다.
   => 이후 page fault를 처리하게 됩니다. 디스크에서 페이지N을 찾아 물리메모리의 빈 프레임에 적재한 후, page table에서 무효비트를 유효비트로 업데이트합니다.
    1. CPU가 페이지 N을 참조합니다.
    2. page table 에서 페이지 N이 메모리에 적재되어 있는지를 (무효한 상태인지를) 확인합니다.
    3. MMU에서 Page Fault Trap을 발생시킵니다.
    4. 디스크에서 페이지 N을 빈 프레임에 적재하고, page table을 업데이트 합니다. (invalid -> valid)

### MMU (Memory Management Unit)
- 가상 주소를 물리 메모리 주소로 변환해주는 하드웨어 장치.
- 주소 변환을 담당하는 하드웨어.
- 메모리에 CPU가 요청한 page가 없으면 page fault trap을 발생시킨다.

( => 이후 디스크에 페이지 N을 찾고 해당 page를 빈 프레임에 적재되면 무효비트를 유효비트로 바꿈 )


## 페이지 교체 알고리즘 (Page Replacement Algorithm)
- page fault가 발생했을 때, 디스크로부터 page를 찾아 메모리에 적재하게 됩니다. 여기서 물리적 메모리에 공간이 부족할 수가 있습니다.
  그럴 경우에는 물리적 메모리에 올라와있는 page를 디스크로 옮겨서 메모리 공간을 확보해야 합니다. 이것을 페이지 교체(page replacement)라고 하고,
  어떤 page를 교체할 것인지 결정하는 알고리즘이 페이지 교체 알고리즘(page replacement algorithm) 입니다.

- 페이지 교체 알고리즘은 page fault가 최대한 적게 일어나도록 도와줘야 합니다.
  따라서 앞으로 참조될 가능성이 적인 page를 선택해서 교체하는 것이 성능을 향상시키는 방법입니다.

## 페이지 교체 알고리즘 종류
1. FIFO (First In First Out)
- 메모리에 **올라온지 가장 오래된 page**를 교체한다.
  
2. LRU (Least Recently Used)
- 가장 **오랫동안 사용되지 않은 page**를 교체한다.
  
3. LFU (Least Frequently Used)
- 물리적메모리에 **존재하는 page 중**에서** 지금까지 **참조 횟수가 가장 적은** page**를 교체한다. (비용대비 성능이 좋지 않아 잘 쓰이진 않음.)
  
4. 최적 페이지 교체
- 앞으로 가장 오랫동안 사용되지 않을 page를 찾아 교체한다. (실제 구현은 어려움.)


